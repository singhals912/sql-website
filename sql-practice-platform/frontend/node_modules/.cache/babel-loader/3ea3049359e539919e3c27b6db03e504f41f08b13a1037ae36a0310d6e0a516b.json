{"ast":null,"code":"import config, { progressUrl } from '../config/environment.js';\nclass ProgressService {\n  constructor() {\n    this.baseURL = progressUrl();\n    this.sessionId = this.getSessionId();\n    this.cache = new Map();\n    this.cacheTimeout = config.CACHE_TIMEOUT;\n  }\n\n  // Get or create session ID\n  getSessionId() {\n    let sessionId = localStorage.getItem('sql_practice_session_id');\n    if (!sessionId) {\n      sessionId = 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);\n      localStorage.setItem('sql_practice_session_id', sessionId);\n    }\n    return sessionId;\n  }\n\n  // Initialize session with backend\n  async initializeSession() {\n    try {\n      const response = await fetch(`${this.baseURL}/session`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'X-Session-ID': this.sessionId\n        },\n        body: JSON.stringify({\n          ipAddress: null,\n          // Browser can't access this\n          userAgent: navigator.userAgent\n        })\n      });\n      const data = await response.json();\n      if (data.success) {\n        // Update session ID if backend created a new one\n        this.sessionId = data.sessionId;\n        localStorage.setItem('sql_practice_session_id', this.sessionId);\n        return data;\n      }\n      throw new Error(data.error || 'Failed to initialize session');\n    } catch (error) {\n      console.error('Failed to initialize session:', error);\n      throw error;\n    }\n  }\n\n  // Check cache before making API call\n  getCachedData(key) {\n    const cached = this.cache.get(key);\n    if (cached && Date.now() - cached.timestamp < this.cacheTimeout) {\n      return cached.data;\n    }\n    return null;\n  }\n\n  // Set cache data\n  setCachedData(key, data) {\n    this.cache.set(key, {\n      data,\n      timestamp: Date.now()\n    });\n  }\n\n  // Clear cache when progress updates\n  clearCache() {\n    this.cache.clear();\n    console.log('DEBUG: Progress cache cleared');\n  }\n\n  // Get comprehensive progress overview\n  async getProgressOverview() {\n    const cacheKey = 'overview';\n    const cached = this.getCachedData(cacheKey);\n    if (cached) {\n      return cached;\n    }\n    try {\n      const response = await fetch(`${this.baseURL}/overview`, {\n        headers: {\n          'X-Session-ID': this.sessionId\n        }\n      });\n      const data = await response.json();\n      if (data.success) {\n        this.setCachedData(cacheKey, data.progress);\n        return data.progress;\n      }\n      throw new Error(data.error || 'Failed to get progress overview');\n    } catch (error) {\n      console.error('Failed to get progress overview:', error);\n      throw error;\n    }\n  }\n\n  // Get detailed problem-by-problem progress\n  async getDetailedProgress() {\n    const cacheKey = 'detailed';\n    const cached = this.getCachedData(cacheKey);\n    if (cached) {\n      return cached;\n    }\n    try {\n      const response = await fetch(`${this.baseURL}/detailed`, {\n        headers: {\n          'X-Session-ID': this.sessionId\n        }\n      });\n      const data = await response.json();\n      if (data.success) {\n        this.setCachedData(cacheKey, data.problems);\n        return data.problems;\n      }\n      throw new Error(data.error || 'Failed to get detailed progress');\n    } catch (error) {\n      console.error('Failed to get detailed progress:', error);\n      throw error;\n    }\n  }\n\n  // Get user statistics\n  async getStats() {\n    try {\n      const response = await fetch(`${this.baseURL}/stats`, {\n        headers: {\n          'X-Session-ID': this.sessionId\n        }\n      });\n      const data = await response.json();\n      if (data.success) {\n        return data.stats;\n      }\n      throw new Error(data.error || 'Failed to get stats');\n    } catch (error) {\n      console.error('Failed to get stats:', error);\n      throw error;\n    }\n  }\n\n  // Get leaderboard\n  async getLeaderboard(limit = 10) {\n    try {\n      const response = await fetch(`${this.baseURL}/leaderboard?limit=${limit}`);\n      const data = await response.json();\n      if (data.success) {\n        return data.leaderboard;\n      }\n      throw new Error(data.error || 'Failed to get leaderboard');\n    } catch (error) {\n      console.error('Failed to get leaderboard:', error);\n      throw error;\n    }\n  }\n\n  // Send heartbeat to keep session active\n  async sendHeartbeat() {\n    try {\n      await fetch(`${this.baseURL}/heartbeat`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'X-Session-ID': this.sessionId\n        }\n      });\n    } catch (error) {\n      console.error('Heartbeat failed:', error);\n    }\n  }\n\n  // Record manual attempt (if needed)\n  async recordAttempt(problemId, problemNumericId, query, isCorrect, executionTimeMs, errorMessage = null, hintUsed = false, solutionViewed = false) {\n    try {\n      const response = await fetch(`${this.baseURL}/attempt`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'X-Session-ID': this.sessionId\n        },\n        body: JSON.stringify({\n          problemId,\n          problemNumericId,\n          query,\n          isCorrect,\n          executionTimeMs,\n          errorMessage,\n          hintUsed,\n          solutionViewed\n        })\n      });\n      const data = await response.json();\n      if (data.success) {\n        return data.attempt;\n      }\n      throw new Error(data.error || 'Failed to record attempt');\n    } catch (error) {\n      console.error('Failed to record attempt:', error);\n      throw error;\n    }\n  }\n}\nexport default new ProgressService();","map":{"version":3,"names":["config","progressUrl","ProgressService","constructor","baseURL","sessionId","getSessionId","cache","Map","cacheTimeout","CACHE_TIMEOUT","localStorage","getItem","Date","now","Math","random","toString","substr","setItem","initializeSession","response","fetch","method","headers","body","JSON","stringify","ipAddress","userAgent","navigator","data","json","success","Error","error","console","getCachedData","key","cached","get","timestamp","setCachedData","set","clearCache","clear","log","getProgressOverview","cacheKey","progress","getDetailedProgress","problems","getStats","stats","getLeaderboard","limit","leaderboard","sendHeartbeat","recordAttempt","problemId","problemNumericId","query","isCorrect","executionTimeMs","errorMessage","hintUsed","solutionViewed","attempt"],"sources":["/Users/ss/Downloads/Code/Vibe_coding/SQL_practice_website/sql-practice-platform/frontend/src/services/progressService.js"],"sourcesContent":["import config, { progressUrl } from '../config/environment.js';\n\nclass ProgressService {\n  constructor() {\n    this.baseURL = progressUrl();\n    this.sessionId = this.getSessionId();\n    this.cache = new Map();\n    this.cacheTimeout = config.CACHE_TIMEOUT;\n  }\n\n  // Get or create session ID\n  getSessionId() {\n    let sessionId = localStorage.getItem('sql_practice_session_id');\n    if (!sessionId) {\n      sessionId = 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);\n      localStorage.setItem('sql_practice_session_id', sessionId);\n    }\n    return sessionId;\n  }\n\n  // Initialize session with backend\n  async initializeSession() {\n    try {\n      const response = await fetch(`${this.baseURL}/session`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'X-Session-ID': this.sessionId\n        },\n        body: JSON.stringify({\n          ipAddress: null, // Browser can't access this\n          userAgent: navigator.userAgent\n        })\n      });\n      \n      const data = await response.json();\n      if (data.success) {\n        // Update session ID if backend created a new one\n        this.sessionId = data.sessionId;\n        localStorage.setItem('sql_practice_session_id', this.sessionId);\n        return data;\n      }\n      throw new Error(data.error || 'Failed to initialize session');\n    } catch (error) {\n      console.error('Failed to initialize session:', error);\n      throw error;\n    }\n  }\n\n  // Check cache before making API call\n  getCachedData(key) {\n    const cached = this.cache.get(key);\n    if (cached && Date.now() - cached.timestamp < this.cacheTimeout) {\n      return cached.data;\n    }\n    return null;\n  }\n\n  // Set cache data\n  setCachedData(key, data) {\n    this.cache.set(key, {\n      data,\n      timestamp: Date.now()\n    });\n  }\n\n  // Clear cache when progress updates\n  clearCache() {\n    this.cache.clear();\n    console.log('DEBUG: Progress cache cleared');\n  }\n\n  // Get comprehensive progress overview\n  async getProgressOverview() {\n    const cacheKey = 'overview';\n    const cached = this.getCachedData(cacheKey);\n    if (cached) {\n      return cached;\n    }\n\n    try {\n      const response = await fetch(`${this.baseURL}/overview`, {\n        headers: {\n          'X-Session-ID': this.sessionId\n        }\n      });\n      \n      const data = await response.json();\n      if (data.success) {\n        this.setCachedData(cacheKey, data.progress);\n        return data.progress;\n      }\n      throw new Error(data.error || 'Failed to get progress overview');\n    } catch (error) {\n      console.error('Failed to get progress overview:', error);\n      throw error;\n    }\n  }\n\n  // Get detailed problem-by-problem progress\n  async getDetailedProgress() {\n    const cacheKey = 'detailed';\n    const cached = this.getCachedData(cacheKey);\n    if (cached) {\n      return cached;\n    }\n\n    try {\n      const response = await fetch(`${this.baseURL}/detailed`, {\n        headers: {\n          'X-Session-ID': this.sessionId\n        }\n      });\n      \n      const data = await response.json();\n      if (data.success) {\n        this.setCachedData(cacheKey, data.problems);\n        return data.problems;\n      }\n      throw new Error(data.error || 'Failed to get detailed progress');\n    } catch (error) {\n      console.error('Failed to get detailed progress:', error);\n      throw error;\n    }\n  }\n\n  // Get user statistics\n  async getStats() {\n    try {\n      const response = await fetch(`${this.baseURL}/stats`, {\n        headers: {\n          'X-Session-ID': this.sessionId\n        }\n      });\n      \n      const data = await response.json();\n      if (data.success) {\n        return data.stats;\n      }\n      throw new Error(data.error || 'Failed to get stats');\n    } catch (error) {\n      console.error('Failed to get stats:', error);\n      throw error;\n    }\n  }\n\n  // Get leaderboard\n  async getLeaderboard(limit = 10) {\n    try {\n      const response = await fetch(`${this.baseURL}/leaderboard?limit=${limit}`);\n      const data = await response.json();\n      \n      if (data.success) {\n        return data.leaderboard;\n      }\n      throw new Error(data.error || 'Failed to get leaderboard');\n    } catch (error) {\n      console.error('Failed to get leaderboard:', error);\n      throw error;\n    }\n  }\n\n  // Send heartbeat to keep session active\n  async sendHeartbeat() {\n    try {\n      await fetch(`${this.baseURL}/heartbeat`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'X-Session-ID': this.sessionId\n        }\n      });\n    } catch (error) {\n      console.error('Heartbeat failed:', error);\n    }\n  }\n\n  // Record manual attempt (if needed)\n  async recordAttempt(problemId, problemNumericId, query, isCorrect, executionTimeMs, errorMessage = null, hintUsed = false, solutionViewed = false) {\n    try {\n      const response = await fetch(`${this.baseURL}/attempt`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'X-Session-ID': this.sessionId\n        },\n        body: JSON.stringify({\n          problemId,\n          problemNumericId,\n          query,\n          isCorrect,\n          executionTimeMs,\n          errorMessage,\n          hintUsed,\n          solutionViewed\n        })\n      });\n      \n      const data = await response.json();\n      if (data.success) {\n        return data.attempt;\n      }\n      throw new Error(data.error || 'Failed to record attempt');\n    } catch (error) {\n      console.error('Failed to record attempt:', error);\n      throw error;\n    }\n  }\n}\n\nexport default new ProgressService();"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}